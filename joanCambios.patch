diff --git a/modules/kernel/src/kernel.c b/modules/kernel/src/kernel.c
index 1b51fa7..3d25b96 100644
--- a/modules/kernel/src/kernel.c
+++ b/modules/kernel/src/kernel.c
@@ -246,7 +246,7 @@ void _planificador_corto_plazo() {
 
     // Desalojo de PCBs
     pthread_t manejo_desalojo;
-    pthread_create(&manejo_desalojo, NULL, manejo_desalojo_pcb, NULL);
+    pthread_create(&manejo_desalojo, NULL, (void*)manejo_desalojo_pcb, NULL);
     pthread_detach(manejo_desalojo);
 
     //Dispatcher
@@ -271,77 +271,112 @@ void _planificador_corto_plazo() {
     }
 }
 
-void *manejo_desalojo_pcb() {
-    for(;;) {
-        sem_wait(&sem_proceso_a_executing);
-        sem_wait(&sem_lista_estados[ENUM_EXECUTING]);
-        PCB* pcb_en_ejecucion = list_get(lista_estados[ENUM_EXECUTING], 0);
-        sem_post(&sem_lista_estados[ENUM_EXECUTING]);
+/*
+** Se utiliza para correr una sola instancia, son dos ciclos anidados,
+** un ciclo padre que controla el semaforo si entro un proceso en ejecucion,
+** y un ciclo hijo que ejecuta el desalojo del proceso, paralelizando los desalojos mediante hilos, corta el ciclo cuando no hay un proceso en EXECUTING
+** @return void
+**
+*/
+void* manejo_desalojo_pcb() {
 
-        timestamp inicio_ejecucion_proceso;
-        timestamp fin_ejecucion_proceso;
+	for(;;)
+	{
+		sem_wait(&sem_proceso_a_executing);
+		while(1){
+			sem_wait(&sem_lista_estados[ENUM_EXECUTING]);
+			PCB* pcb_en_ejecucion = list_get(lista_estados[ENUM_EXECUTING], 0);
+			sem_post(&sem_lista_estados[ENUM_EXECUTING]);
 
-        set_timespec(&inicio_ejecucion_proceso);
-        envio_pcb_a_cpu(conexionCPU, pcb_en_ejecucion, OP_EXECUTE_PCB);
+			timestamp inicio_ejecucion_proceso;
+			timestamp fin_ejecucion_proceso;
 
-        codigo_operacion operacionRecibida = recibir_operacion(conexionCPU);
-        log_info(kernelLogger, "CODIGO DE OPERACION RECIBIDO: %d", operacionRecibida);
+			set_timespec(&inicio_ejecucion_proceso);
+			envio_pcb_a_cpu(conexionCPU, pcb_en_ejecucion, OP_EXECUTE_PCB);
 
-        pcb_en_ejecucion = recibir_proceso_desajolado(pcb_en_ejecucion);
-        set_timespec(&fin_ejecucion_proceso);
+			codigo_operacion operacionRecibida = recibir_operacion(conexionCPU);
+			log_info(kernelLogger, "CODIGO DE OPERACION RECIBIDO: %d", operacionRecibida);
 
-         // Actualizo el estimado en el pcb segun el real ejecutado
-         double tiempo_en_cpu = obtener_diferencial_de_tiempo_en_milisegundos(&fin_ejecucion_proceso, &inicio_ejecucion_proceso);
-         pcb_estimar_proxima_rafaga(pcb_en_ejecucion, tiempo_en_cpu);
+			set_timespec(&fin_ejecucion_proceso);
 
-         char* ultimaInstruccion = malloc(sizeof(char*));
-         char** ultimaInstruccionDecodificada = malloc(sizeof(char*));
-         ultimaInstruccion = string_duplicate((char *)list_get(pcb_en_ejecucion->lista_instrucciones, pcb_en_ejecucion->contador_instrucciones));
-         ultimaInstruccionDecodificada = decode_instruccion(ultimaInstruccion, kernelLogger);
+			PCB* pcb_devuelto = recibir_proceso_desajolado(pcb_en_ejecucion);
 
-         switch(operacionRecibida) {
-            case I_YIELD: {
-                break;
-            }
-            case I_F_OPEN: {
-                char* nombreArchivo = ultimaInstruccionDecodificada[1];
+			// Actualizo el estimado en el pcb segun el real ejecutado
+			double tiempo_en_cpu = obtener_diferencial_de_tiempo_en_milisegundos(&fin_ejecucion_proceso, &inicio_ejecucion_proceso);
+
+			pcb_estimar_proxima_rafaga(pcb_devuelto, tiempo_en_cpu);
+
+			char* ultimaInstruccion = malloc(sizeof(char*));
+			char** ultimaInstruccionDecodificada = malloc(sizeof(char*));
+			ultimaInstruccion = string_duplicate((char *)list_get(pcb_devuelto->lista_instrucciones, pcb_devuelto->contador_instrucciones));
+			ultimaInstruccionDecodificada = decode_instruccion(ultimaInstruccion, kernelLogger);
+
+			t_data_desalojo* data;
+			data->operacion = operacionRecibida;
+			data->pcb = pcb_devuelto;
+			data->instruccion = ultimaInstruccionDecodificada;
+
+			// Paralelizar el manejo de desalojos
+			pthread_t hilo_manejo_operaciones_desalojo;
+			pthread_create(&hilo_manejo_operaciones_desalojo, NULL, (void*) manejo_operaciones_desalojo, (void*) data);
+			pthread_detach(hilo_manejo_operaciones_desalojo);
+		}
+	}
+}
+
+void manejo_operaciones_desalojo(void* data){
+	codigo_operacion res = manejo_instrucciones(data);
+	if(res==AUX_SOLO_CON_COMPACTACION){
+		t_data_desalojo* data2 = (t_data_desalojo*)data;
+		data2->operacion=AUX_SOLICITUD_COMPACTACION;
+		res = manejo_instrucciones(data2);}
+}
+
+codigo_operacion manejo_instrucciones(void* _data){
+	codigo_operacion res;
+	t_data_desalojo* data = (t_data_desalojo*)_data;
+	 PCB* pcb = data->pcb;
+	 int id_proceso = pcb->id_proceso;
+
+	switch(data->operacion) {
+               case I_YIELD: {
+                  break;
+               }
+                case I_F_OPEN: {
+                bool estaEnReady = true;
+                char* nombreArchivo = data->instruccion[1];
                 strtok(nombreArchivo, "$");
 
-                bool existeSemaforo = dictionary_has_key(tablaArchivosAbiertos, nombreArchivo);
+                t_semaforo_recurso* semaforoArchivo = (t_semaforo_recurso*) dictionary_get(tablaArchivosAbiertos, nombreArchivo);
+                t_estado* estado = semaforoArchivo == NULL ? NULL : semaforoArchivo->estadoRecurso;
 
-                if (existeSemaforo) {
-                	 t_semaforo_recurso* semaforoArchivo = (t_semaforo_recurso*) dictionary_get(tablaArchivosAbiertos, nombreArchivo);
-                	 t_estado* estado = semaforoArchivo == NULL ? NULL : semaforoArchivo->estadoRecurso;
+                if (semaforoArchivo != NULL) {
                     // Esta abierto y siendo usado, hay que bloquearlo
                     pthread_mutex_lock(estado->mutexEstado);
 
-                    list_add(estado->listaProcesos, pcb_en_ejecucion);
-
-                    cambiar_estado_proceso_con_semaforos(pcb_en_ejecucion, ENUM_BLOCKED);
+                    list_add(estado->listaProcesos, pcb);
 
+                    cambiar_estado_proceso_con_semaforos(pcb, ENUM_BLOCKED);
                     pthread_mutex_unlock(estado->mutexEstado);
                     semaforoArchivo->instancias--;
                     sem_post(estado->semaforoEstado);
                     sem_post(&sem_proceso_a_ready_terminado);
-                    continue;
+                    // continue;
                 }
 
-                size_t tamanioPalabra = strlen(nombreArchivo);
-//                log_error(kernelLogger, "El tamanio del nombre de archivo es %zu", tamanioPalabra);
+                size_t tamanioPalabra = strlen(nombreArchivo)-1;
+                log_error(kernelLogger, "El tamanio del nombre de archivo es %zu", tamanioPalabra);
 
-                enviar_operacion(conexionFileSystem, operacionRecibida, tamanioPalabra, nombreArchivo);
-                codigo_operacion operacionDelFileSystem = recibir_operacion(conexionFileSystem);
-                int ceroBasura = recibir_operacion(conexionFileSystem);
+                enviar_operacion(conexionFileSystem, data->operacion, tamanioPalabra, nombreArchivo);
+                codigo_operacion operacionRecibida = recibir_operacion(conexionFileSystem);
 
-                if (operacionDelFileSystem != AUX_OK) {
+                if (operacionRecibida != AUX_OK) {
                     // Si no existe lo creo
                     enviar_operacion(conexionFileSystem, KERNEL_CREAR_ARCHIVO, tamanioPalabra, nombreArchivo);
                     recibir_operacion(conexionFileSystem);
-                    recibir_operacion(conexionFileSystem); // Por 0 basura
                 }
 
                 // abrir archivo globalmente
-                t_semaforo_recurso* semaforoArchivo = malloc(sizeof(t_semaforo_recurso));
                 semaforoArchivo->instancias = 0;
                 semaforoArchivo->estadoRecurso = crear_archivo_estado(ENUM_ARCHIVO_BLOCK);
                 dictionary_put(tablaArchivosAbiertos, nombreArchivo, semaforoArchivo);
@@ -351,20 +386,18 @@ void *manejo_desalojo_pcb() {
                 archivoAbierto->puntero = 0;
 
                 // abrir archivo proceso
-                list_add(pcb_en_ejecucion->lista_archivos_abiertos, archivoAbierto);
+                list_add(data->pcb->lista_archivos_abiertos, archivoAbierto);
 
 
-                cambiar_estado_proceso_con_semaforos(pcb_en_ejecucion, ENUM_READY);
+                cambiar_estado_proceso_con_semaforos(pcb, ENUM_READY);
 
-                sem_post(&sem_proceso_a_ready_terminado);
-                sem_post(&sem_cpu_disponible);
                 break;
             }
 
             case I_F_CLOSE: {
-                char* nombreArchivo = ultimaInstruccionDecodificada[1];
+                char* nombreArchivo = data->instruccion[1];
                 strtok(nombreArchivo, "$");
-                list_remove_element(pcb_en_ejecucion->lista_archivos_abiertos, nombreArchivo);
+                list_remove_element(data->pcb->lista_archivos_abiertos, nombreArchivo);
 
                 t_semaforo_recurso* semaforoArchivo = (t_semaforo_recurso*) dictionary_get(tablaArchivosAbiertos, nombreArchivo);
                 t_estado* estado = semaforoArchivo->estadoRecurso;
@@ -383,51 +416,93 @@ void *manejo_desalojo_pcb() {
                 }
 
                 sem_post(&sem_proceso_a_executing);
-                sem_post(&sem_cpu_disponible);
                 break;
             }
 
             case I_TRUNCATE: {
-                char* nombreArchivo = ultimaInstruccionDecodificada[1];
+                char* nombreArchivo = data->instruccion[1];
                 strtok(nombreArchivo, "$");
-                cambiar_estado_proceso_con_semaforos(pcb_en_ejecucion, ENUM_BLOCKED);
+                cambiar_estado_proceso_con_semaforos(data->pcb, ENUM_BLOCKED);
 
                 t_archivo_abierto* archivo;
                 archivo->nombreArchivo = nombreArchivo;
-                archivo->puntero = (uint32_t)(uintptr_t)ultimaInstruccionDecodificada[2];
-                // cambiar_estado_proceso_con_semaforos(pcb_en_ejecucion, ENUM_BLOCKED);
-                enviar_operacion(conexionFileSystem, operacionRecibida, sizeof(t_archivo_abierto), archivo);
+                archivo->puntero = (uint32_t)(uintptr_t)data->instruccion[2];
+                // cambiar_estado_proceso_con_semaforos(data->pcb, ENUM_BLOCKED);
+                enviar_operacion(conexionFileSystem, data->operacion, sizeof(t_archivo_abierto), archivo);
                 recibir_operacion(conexionFileSystem);
 
-                cambiar_estado_proceso_con_semaforos(pcb_en_ejecucion, ENUM_READY);
+                cambiar_estado_proceso_con_semaforos(data->pcb, ENUM_READY);
                 sem_post(&sem_proceso_a_ready_terminado);
                 break;
             }
 
             case I_F_SEEK: {
-                char* nombreArchivo = ultimaInstruccionDecodificada[1];
-                uint32_t puntero = (uint32_t)(uintptr_t)ultimaInstruccionDecodificada[2];
+                char* nombreArchivo = data->instruccion[1];
+                uint32_t puntero = (uint32_t)(uintptr_t)data->instruccion[2];
                 strtok(nombreArchivo, "$");
-                t_archivo_abierto* archivoAbierto = encontrar_archivo_abierto(pcb_en_ejecucion->lista_archivos_abiertos, nombreArchivo);
+                t_archivo_abierto* archivoAbierto = encontrar_archivo_abierto(pcb->lista_archivos_abiertos, nombreArchivo);
                 archivoAbierto->puntero = puntero;
                 sem_post(&sem_proceso_a_executing);
 
                 break;
             }
             case I_F_READ: {
-                cambiar_estado_proceso_con_semaforos(pcb_en_ejecucion, ENUM_BLOCKED);
-                enviar_f_read_write(pcb_en_ejecucion, ultimaInstruccionDecodificada, operacionRecibida);
-                break;
-            }
-            case I_F_WRITE: {
+                cambiar_estado_proceso_con_semaforos(pcb, ENUM_BLOCKED);
+                enviar_f_read_write(data->pcb, data->instruccion, data->operacion);
                 break;
             }
-
-         free(ultimaInstruccion);
-         free(ultimaInstruccionDecodificada);
-        }
-    }
-    return NULL;
+			 case AUX_SOLICITUD_COMPACTACION: {
+				pthread_mutex_lock(&permiso_compactacion);
+
+				log_info(kernelLogger,INICIO_COMPACTACIÓN);
+				enviar_operacion(conexionMemoria, data->operacion, sizeof(int*),1);
+				res=recibir_operacion(conexionMemoria);
+
+				pthread_mutex_unlock(&permiso_compactacion);
+				if(res==AUX_OK){log_info(kernelLogger,FIN_COMPACTACIÓN);}
+				else{log_error(kernelLogger,"E__COMPACTACION");}
+				break;
+			 }
+			 case I_CREATE_SEGMENT: {
+				t_segmento* segmento;
+				segmento->direccionBase = 0;
+				segmento->id = atoi(data->instruccion[1]);
+				segmento->size = (size_t)data->instruccion[2];
+
+				enviar_operacion(conexionMemoria, data->operacion, sizeof(t_segmento*), segmento);
+				res = recibir_operacion(conexionMemoria);
+				if (res == AUX_OK){
+					log_info(kernelConfig,CREAR_SEGMENTO,data->pcb->id_proceso,segmento->id,segmento->size);
+				} else if(res == AUX_SOLO_CON_COMPACTACION){
+					break;
+				} else {
+					log_error(kernelLogger,E__BAD_REQUEST);
+				}
+				break;
+			 }
+			 case I_DELETE_SEGMENT: {
+				int id_segmento = atoi(data->instruccion[1]);
+
+				enviar_operacion(conexionMemoria, data->operacion, sizeof(int), (void*) (intptr_t)id_segmento);
+				res = recibir_operacion(conexionMemoria);
+				if (res == AUX_OK){
+					log_info(kernelConfig, ELIMINAR_SEGMENTO,data->pcb->id_proceso,id_segmento);
+				}else{
+					log_error(kernelLogger, ELIMINAR_SEGMENTO,data->pcb->id_proceso,id_segmento);
+				}
+				break;
+			 }
+
+			 case I_F_WRITE: {
+				pthread_mutex_lock(&permiso_compactacion);
+
+				pthread_mutex_unlock(&permiso_compactacion);
+			 }
+			 default:
+                   res=AUX_ERROR;
+			 break;
+		 }
+	return res;
 }
 
 void enviar_f_read_write(PCB* pcb, char** instruccion, codigo_operacion codigoOperacion) {
diff --git a/modules/kernel/src/kernel.h b/modules/kernel/src/kernel.h
index 4f98462..58f41c6 100644
--- a/modules/kernel/src/kernel.h
+++ b/modules/kernel/src/kernel.h
@@ -70,10 +70,20 @@ typedef struct {
 
 typedef struct timespec timestamp;
 
+typedef struct{
+    codigo_operacion operacion;
+    PCB* pcb;
+    char** instruccion;
+}t_data_desalojo;
+
+
 pthread_mutex_t permiso_compactacion;
 
+
 /*----------------- FUNCIONES ------------------*/
 
+codigo_operacion manejo_instrucciones(void* _data);
+
 void inicializar_estructuras();
 void _planificador_largo_plazo();
 void* liberar_pcb_de_exit();
@@ -159,6 +169,8 @@ t_semaforo_recurso* inicializar_archivo_estado(t_nombre_estado nombreEstado);
 
 t_list* archivosAbiertosGlobal;
 
+void manejo_operaciones_desalojo(void* data);
+
 /*----------------- SEMAFOROS / HILOS ------------------*/
 sem_t sem_proceso_a_ready_inicializar;
 sem_t sem_proceso_a_ready_terminado;
